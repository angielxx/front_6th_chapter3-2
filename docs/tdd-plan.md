# TDD 기반 반복 일정 기능 구현 계획

## 1. 프로젝트 개요

캘린더 애플리케이션에 반복 일정 기능을 TDD 방식으로 구현하는 프로젝트입니다.

### 핵심 요구사항

1. **반복 유형 선택**: 매일, 매주, 매월, 매년
2. **반복 일정 표시**: 캘린더에서 아이콘으로 구분
3. **반복 종료**: 특정 날짜까지 (2025-10-30)
4. **단일 수정**: 반복 일정 수정 시 단일 일정으로 변경
5. **단일 삭제**: 반복 일정 삭제 시 해당 일정만 삭제

## 2. TDD 개발 단계별 계획

### Phase 1: 통합 테스트 우선 작성 (Outside-In TDD)

#### 1.1 실패하는 통합 테스트 작성

```typescript
// __tests__/integration/recurringEventFlow.spec.tsx
describe('RecurringEventFlow', () => {
  describe('반복 일정 전체 플로우', () => {
    it('매일 반복 일정을 생성하고 캘린더에서 확인할 수 있다', async () => {
      // Given: 일정 생성 폼
      const { user } = setup(<App />);

      // When: 매일 반복 일정 생성
      await user.click(screen.getAllByText('일정 추가')[0]);
      await user.type(screen.getByLabelText('제목'), '매일 운동');
      await user.type(screen.getByLabelText('날짜'), '2025-01-01');
      await user.type(screen.getByLabelText('시작 시간'), '07:00');
      await user.type(screen.getByLabelText('종료 시간'), '08:00');

      // 반복 유형 선택 (새로운 UI 요소)
      await user.click(screen.getByLabelText('반복 유형'));
      await user.click(screen.getByRole('option', { name: '매일' }));

      await user.click(screen.getByTestId('event-submit-button'));

      // Then: 캘린더에서 반복 일정이 아이콘과 함께 표시되어야 함
      const calendar = screen.getByTestId('calendar');
      expect(within(calendar).getByTestId('recurring-icon-2025-01-01')).toBeInTheDocument();
      expect(within(calendar).getByTestId('recurring-icon-2025-01-02')).toBeInTheDocument();
      expect(within(calendar).getByTestId('recurring-icon-2025-01-03')).toBeInTheDocument();
    });

    it('반복 일정을 수정하면 단일 일정으로 변경된다', async () => {
      // Given: 매일 반복 일정이 있는 상태
      // When: 특정 일정을 수정
      // Then: 해당 일정만 단일 일정으로 변경되고 아이콘이 사라짐
    });

    it('반복 일정을 삭제하면 해당 일정만 삭제된다', async () => {
      // Given: 매일 반복 일정이 있는 상태
      // When: 특정 일정을 삭제
      // Then: 해당 일정만 삭제되고 다른 반복 일정은 유지됨
    });
  });
});
```

#### 1.2 성공하는 통합 테스트 작성

- 다양한 반복 유형 (매주, 매월, 매년) 테스트
- 경계값 테스트 (31일 매월, 윤년 2월 29일)
- 종료 날짜 설정 테스트

#### 1.3 구현 코드 작성

- 반복 일정 UI 컴포넌트 구현
- 반복 일정 생성/수정/삭제 로직 구현
- 캘린더 표시 로직 수정

#### 1.4 리팩토링

- 컴포넌트 분리 및 재사용성 개선
- 비즈니스 로직 모듈화

### Phase 2: 단위 테스트 보강 (Inside-Out TDD)

#### 2.1 실패하는 단위 테스트 작성

```typescript
// __tests__/unit/recurringEventUtils.spec.ts
describe('RecurringEventUtils', () => {
  describe('날짜 계산 로직', () => {
    it('매일 반복 일정의 다음 날짜를 계산할 수 있다', () => {
      // Given: 2025-01-01 매일 반복 일정
      // When: 다음 날짜 계산
      // Then: 2025-01-02 반환
    });

    it('매주 반복 일정의 다음 날짜를 계산할 수 있다', () => {
      // Given: 2025-01-01(수요일) 매주 반복 일정
      // When: 다음 날짜 계산
      // Then: 2025-01-08(수요일) 반환
    });

    it('매월 반복 일정의 다음 날짜를 계산할 수 있다', () => {
      // Given: 2025-01-31 매월 반복 일정
      // When: 다음 날짜 계산
      // Then: 2025-02-28 반환 (2월은 28일까지만)
    });

    it('매년 반복 일정의 다음 날짜를 계산할 수 있다', () => {
      // Given: 2024-02-29(윤년) 매년 반복 일정
      // When: 다음 날짜 계산
      // Then: 2025-02-28 반환 (평년은 28일까지만)
    });
  });

  describe('반복 일정 생성 로직', () => {
    it('종료 날짜까지 반복 일정을 생성할 수 있다', () => {
      // Given: 2025-01-01부터 2025-01-05까지 매일 반복
      // When: 반복 일정 생성
      // Then: 5개의 일정이 생성되어야 함
    });
  });
});
```

#### 2.2 성공하는 단위 테스트 작성

- 경계값 테스트 (31일, 윤년 등)
- 예외 상황 테스트 (잘못된 날짜 입력)
- 성능 테스트 (대량의 반복 일정)

#### 2.3 구현 코드 작성

- `recurringEventUtils.ts` 유틸리티 함수 구현
- 날짜 계산 로직 구현
- 반복 일정 생성 로직 구현

#### 2.4 리팩토링

- 함수 분리 및 단일 책임 원칙 적용
- 중복 코드 제거
- 성능 최적화

### Phase 3: 훅 테스트 작성

#### 3.1 실패하는 훅 테스트 작성

```typescript
// __tests__/hooks/useRecurringEvents.spec.ts
describe('useRecurringEvents', () => {
  describe('반복 일정 관리', () => {
    it('반복 일정을 생성할 수 있다', () => {
      // Given: useRecurringEvents 훅
      // When: 반복 일정 생성 함수 호출
      // Then: 반복 일정이 생성되어야 함
    });

    it('반복 일정을 수정할 수 있다', () => {
      // Given: 기존 반복 일정
      // When: 특정 일정 수정
      // Then: 해당 일정만 단일 일정으로 변경되어야 함
    });

    it('반복 일정을 삭제할 수 있다', () => {
      // Given: 기존 반복 일정
      // When: 특정 일정 삭제
      // Then: 해당 일정만 삭제되어야 함
    });

    it('종료 날짜까지 반복 일정을 필터링할 수 있다', () => {
      // Given: 종료 날짜가 설정된 반복 일정
      // When: 특정 날짜 범위 조회
      // Then: 종료 날짜 이후 일정은 제외되어야 함
    });
  });
});
```

#### 3.2 성공하는 훅 테스트 작성

- 다양한 반복 유형별 테스트
- 상태 변경 테스트
- 에러 처리 테스트

#### 3.3 구현 코드 작성

- `useRecurringEvents` 훅 구현
- 반복 일정 상태 관리 로직 구현
- CRUD 작업 로직 구현

#### 3.4 리팩토링

- 훅 로직 모듈화
- 상태 관리 최적화

### Phase 4: 컴포넌트 테스트 작성

#### 4.1 실패하는 컴포넌트 테스트 작성

```typescript
// __tests__/unit/RecurringEventIcon.spec.tsx
describe('RecurringEventIcon', () => {
  describe('반복 일정 아이콘', () => {
    it('반복 일정에 아이콘이 표시되어야 한다', () => {
      // Given: 반복 일정 데이터
      // When: RecurringEventIcon 컴포넌트 렌더링
      // Then: 반복 아이콘이 표시되어야 함
    });

    it('반복 유형에 따라 다른 아이콘이 표시되어야 한다', () => {
      // Given: 매일, 매주, 매월, 매년 반복 일정
      // When: 각각의 RecurringEventIcon 컴포넌트 렌더링
      // Then: 각각 다른 아이콘이 표시되어야 함
    });
  });
});

// __tests__/unit/RecurringEventForm.spec.tsx
describe('RecurringEventForm', () => {
  describe('반복 일정 폼', () => {
    it('반복 유형을 선택할 수 있어야 한다', () => {
      // Given: 반복 일정 폼
      // When: 반복 유형 선택
      // Then: 선택된 유형이 반영되어야 함
    });

    it('종료 날짜를 설정할 수 있어야 한다', () => {
      // Given: 반복 일정 폼
      // When: 종료 날짜 입력
      // Then: 입력된 종료 날짜가 반영되어야 함
    });
  });
});
```

#### 4.2 성공하는 컴포넌트 테스트 작성

- 다양한 props 조합 테스트
- 사용자 인터랙션 테스트
- 에러 상태 테스트

#### 4.3 구현 코드 작성

- `RecurringEventIcon` 컴포넌트 구현
- `RecurringEventForm` 컴포넌트 구현
- 반복 일정 관련 UI 컴포넌트들 구현

#### 4.4 리팩토링

- 컴포넌트 재사용성 개선
- 스타일링 분리
- 접근성 개선

## 3. 테스트 전략 및 우선순위

### 3.1 Outside-In TDD (통합 테스트 우선)

**이유**: 반복 일정 기능은 여러 컴포넌트와 훅이 협력해야 하는 복잡한 기능이므로, 전체 플로우를 먼저 정의하고 점진적으로 세부 구현을 완성하는 것이 효율적입니다.

**장점**:

- 사용자 관점에서 기능 요구사항을 명확히 정의
- 컴포넌트 간 인터페이스를 먼저 설계
- 전체 시스템의 동작을 보장

### 3.2 Inside-Out TDD (단위 테스트 보강)

**이유**: 복잡한 비즈니스 로직(날짜 계산, 반복 패턴)은 독립적으로 테스트하고 검증해야 합니다.

**장점**:

- 복잡한 로직의 정확성 보장
- 리팩토링 시 안전성 확보
- 성능 최적화 시 신뢰성 확보

### 3.3 테스트 피라미드 적용

```
    E2E Tests (적음)
   ┌─────────────┐
   │ Integration │ (중간)
   │   Tests     │
   └─────────────┘
  ┌─────────────────┐
  │   Unit Tests    │ (많음)
  └─────────────────┘
```

**단위 테스트 (70%)**: 유틸리티 함수, 훅, 비즈니스 로직
**통합 테스트 (20%)**: 컴포넌트 간 상호작용, 전체 플로우
**E2E 테스트 (10%)**: 사용자 시나리오 검증

## 4. 구체적인 테스트 케이스

### 4.1 통합 테스트 케이스

#### 4.1.1 반복 일정 생성 플로우

```typescript
describe('반복 일정 생성 플로우', () => {
  it('매일 반복 일정을 생성하고 캘린더에서 확인할 수 있다', async () => {
    // Given: 일정 생성 폼
    // When: 매일 반복 일정 생성
    // Then: 캘린더에서 연속된 날짜에 일정이 표시되어야 함
  });

  it('매주 반복 일정을 생성하고 같은 요일에 표시된다', async () => {
    // Given: 월요일 일정 생성
    // When: 매주 반복 설정
    // Then: 이후 모든 월요일에 일정이 표시되어야 함
  });

  it('매월 반복 일정을 생성하고 같은 날짜에 표시된다', async () => {
    // Given: 15일 일정 생성
    // When: 매월 반복 설정
    // Then: 이후 모든 달의 15일에 일정이 표시되어야 함
  });
});
```

#### 4.1.2 반복 일정 수정 플로우

```typescript
describe('반복 일정 수정 플로우', () => {
  it('반복 일정을 수정하면 해당 일정만 단일 일정으로 변경된다', async () => {
    // Given: 매일 반복 일정이 있는 상태
    // When: 특정 일정을 수정
    // Then: 해당 일정만 단일 일정으로 변경되고 아이콘이 사라짐
  });

  it('수정된 일정은 원본 반복 일정과 독립적으로 동작한다', async () => {
    // Given: 수정된 반복 일정
    // When: 원본 반복 일정 삭제
    // Then: 수정된 일정은 그대로 유지되어야 함
  });
});
```

### 4.2 단위 테스트 케이스

#### 4.2.1 날짜 계산 로직

```typescript
describe('날짜 계산 로직', () => {
  it('31일 매월 반복 시 2월은 28일까지만 생성한다', () => {
    // Given: 2025-01-31 매월 반복
    // When: 다음 날짜 계산
    // Then: 2025-02-28 반환
  });

  it('윤년 2월 29일 매년 반복 시 평년은 2월 28일까지만 생성한다', () => {
    // Given: 2024-02-29 매년 반복
    // When: 다음 날짜 계산
    // Then: 2025-02-28 반환
  });
});
```

#### 4.2.2 반복 일정 생성 로직

```typescript
describe('반복 일정 생성 로직', () => {
  it('종료 날짜까지 반복 일정을 생성한다', () => {
    // Given: 2025-01-01부터 2025-01-05까지 매일 반복
    // When: 반복 일정 생성
    // Then: 5개의 일정이 생성되어야 함
  });

  it('종료 날짜 이후에는 일정을 생성하지 않는다', () => {
    // Given: 2025-01-01부터 2025-01-05까지 매일 반복
    // When: 2025-01-06 이후 조회
    // Then: 일정이 없어야 함
  });
});
```

## 5. 구현 우선순위 및 접근법

### 5.1 Outside-In TDD 접근법

**1단계: 통합 테스트 작성 (실패하는 테스트)**

- 전체 사용자 플로우를 정의하는 통합 테스트 작성
- 반복 일정 생성 → 표시 → 수정 → 삭제 전체 시나리오

**2단계: 최소한의 구현으로 통합 테스트 통과**

- 테스트를 통과시키기 위한 최소한의 코드 작성
- 하드코딩이나 임시 구현도 허용

**3단계: 단위 테스트 작성 (실패하는 테스트)**

- 복잡한 비즈니스 로직에 대한 단위 테스트 작성
- 날짜 계산, 반복 패턴 생성 등

**4단계: 단위 테스트 통과를 위한 구현**

- 단위 테스트를 통과시키는 실제 로직 구현

**5단계: 리팩토링**

- 코드 개선 및 중복 제거
- 성능 최적화

### 5.2 구체적인 구현 순서

#### 5.2.1 1차 구현 (MVP - 통합 테스트 우선)

1. **통합 테스트 작성**: 반복 일정 생성 플로우
2. **최소 구현**: 하드코딩으로 통합 테스트 통과
3. **단위 테스트 작성**: 날짜 계산 로직
4. **실제 구현**: 날짜 계산 유틸리티 함수

#### 5.2.2 2차 구현 (핵심 기능)

1. **통합 테스트 작성**: 수정/삭제 플로우
2. **단위 테스트 작성**: 수정/삭제 로직
3. **구현**: 수정/삭제 기능

#### 5.2.3 3차 구현 (고도화)

1. **성능 테스트 작성**
2. **최적화**: 대량 데이터 처리
3. **사용자 경험 개선**

## 6. 품질 기준 및 검증 방법

### 6.1 코드 품질

- **함수당 20줄 이하**: 복잡한 로직은 작은 함수로 분리
- **단일 책임 원칙**: 각 함수/클래스가 하나의 명확한 책임만 가짐
- **명확한 네이밍**: 함수명과 변수명이 의도를 명확히 표현
- **적절한 주석**: 복잡한 비즈니스 로직에만 주석 작성

### 6.2 테스트 품질

- **각 테스트가 하나의 동작만 검증**: 테스트 이름이 검증할 동작을 명확히 표현
- **긍정적/부정적 케이스 모두 포함**: 정상 동작과 예외 상황 모두 테스트
- **경계값 테스트 포함**: 31일, 윤년, 종료 날짜 등 경계값 테스트
- **테스트 코드의 가독성**: Given-When-Then 구조로 명확한 테스트 작성

### 6.3 성능 기준

- **반복 일정 렌더링 성능**: 1000개 이상의 반복 일정도 부드럽게 렌더링
- **메모리 사용량 최적화**: 불필요한 객체 생성 최소화
- **사용자 인터랙션 응답성**: 클릭/입력에 100ms 이내 응답

### 6.4 검증 방법

- **코드 리뷰**: Clean Code 원칙 준수 여부 검토
- **테스트 커버리지**: 90% 이상의 테스트 커버리지 유지
- **성능 테스트**: 대량 데이터 처리 시 성능 측정
- **사용자 테스트**: 실제 사용자 시나리오 검증

## 7. 리스크 관리 및 대응 방안

### 7.1 기술적 리스크

- **복잡한 날짜 계산 로직의 버그**: 31일, 윤년 등 특수한 날짜 처리
- **성능 이슈**: 대량의 반복 일정 처리 시 렌더링 성능 저하
- **브라우저 호환성 문제**: 다양한 브라우저에서의 날짜 처리 차이
- **상태 관리 복잡성**: 반복 일정과 단일 일정의 혼재 상태 관리

### 7.2 대응 방안

- **철저한 단위 테스트 작성**: 날짜 계산 로직에 대한 경계값 테스트
- **성능 테스트 및 최적화**: 가상화(virtualization) 적용, 메모이제이션 활용
- **크로스 브라우저 테스트**: 주요 브라우저에서의 동작 검증
- **상태 관리 패턴 적용**: 명확한 상태 분리 및 불변성 유지

### 7.3 예상 문제점 및 해결책

#### 7.3.1 날짜 계산 복잡성

**문제**: 31일 매월 반복, 윤년 처리 등 복잡한 날짜 로직
**해결책**:

- 날짜 라이브러리 활용 (date-fns, dayjs)
- 철저한 단위 테스트로 경계값 검증
- 명확한 비즈니스 규칙 문서화

#### 7.3.2 성능 이슈

**문제**: 대량의 반복 일정 렌더링 시 성능 저하
**해결책**:

- 가상화된 캘린더 컴포넌트 사용
- 반복 일정 캐싱 및 메모이제이션
- 지연 로딩(lazy loading) 적용

#### 7.3.3 사용자 경험

**문제**: 복잡한 반복 일정 관리로 인한 사용자 혼란
**해결책**:

- 직관적인 UI/UX 설계
- 명확한 시각적 구분 (아이콘, 색상)
- 단계별 가이드 제공

## 8. 마일스톤 및 진행 계획

### Week 1: 통합 테스트 기반 MVP 구현

**목표**: 반복 일정 생성 및 표시 기능의 기본 동작 확인

**주요 작업**:

- 통합 테스트 작성 (실패하는 테스트)
- 최소한의 구현으로 통합 테스트 통과
- 기본적인 반복 일정 생성 기능
- 캘린더에서 반복 일정 표시

**산출물**:

- 통합 테스트 코드
- 기본 반복 일정 생성 기능
- 반복 일정 표시 UI

### Week 2: 단위 테스트 및 비즈니스 로직 구현

**목표**: 복잡한 비즈니스 로직의 정확성 보장

**주요 작업**:

- 날짜 계산 로직 단위 테스트 작성
- 반복 일정 생성 로직 단위 테스트 작성
- 실제 비즈니스 로직 구현
- 종료 날짜 기능 구현

**산출물**:

- 단위 테스트 코드
- 날짜 계산 유틸리티 함수
- 반복 일정 생성 로직

### Week 3: 수정 및 삭제 기능 구현

**목표**: 반복 일정의 수정 및 삭제 기능 완성

**주요 작업**:

- 수정/삭제 통합 테스트 작성
- 수정/삭제 단위 테스트 작성
- 수정/삭제 기능 구현
- UI 컴포넌트 구현

**산출물**:

- 수정/삭제 기능
- 관련 UI 컴포넌트
- 테스트 코드

### Week 4: 최적화 및 완성

**목표**: 성능 최적화 및 전체 기능 완성

**주요 작업**:

- 성능 테스트 작성 및 최적화
- 코드 리팩토링
- 버그 수정
- 문서화

**산출물**:

- 최적화된 코드
- 완성된 기능
- 테스트 문서
